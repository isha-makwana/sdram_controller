
//


`timescale 1ns / 1ps

module sdram_controller(
    input               iclk,
    input               ireset,

    input               iwrite_req,
    input      [21:0]   iwrite_address,
    input     [127:0]   iwrite_data,
    output              owrite_ack,

    input               iread_req,
    input      [21:0]   iread_address,
    output    [127:0]   oread_data,
    output              oread_ack,

    output              oinit_done,

    output     [12:0]   DRAM_ADDR,
    output      [1:0]   DRAM_BA,
    output              DRAM_CAS_N,
    output              DRAM_CKE,
    output              DRAM_CLK,
    output              DRAM_CS_N,
    inout      [15:0]   DRAM_DQ,
    output              DRAM_LDQM,
    output              DRAM_RAS_N,
    output              DRAM_UDQM,
    output              DRAM_WE_N
);

// FIFO signals
wire [149:0] write_fifo_rd_data;
wire         write_fifo_full, write_fifo_empty;
reg          write_fifo_rd_en;
reg         write_fifo_wr_en;  // push when write requested
reg [149:0] write_fifo_wr_data;
reg [21:0] latched_write_address;
reg [127:0] latched_write_data;
reg [21:0] latched_read_address;

// Instantiate write FIFO
sdram_write_fifo write_fifo (
    .clk(iclk),
    .reset(ireset),
    .wr_en(write_fifo_wr_en),
    .rd_en(write_fifo_rd_en),
    .wr_data(write_fifo_wr_data),
    .rd_data(write_fifo_rd_data),
    .full(write_fifo_full),
    .empty(write_fifo_empty)
);

// Read FIFO signals
wire read_fifo_full, read_fifo_empty;
wire [21:0] read_fifo_rd_data;
reg  read_fifo_rd_en;
reg  read_fifo_wr_en;
reg  [21:0] read_fifo_wr_data;

sdram_read_fifo #(
    .ADDR_WIDTH(4),
    .DATA_WIDTH(22)
) read_fifo (
    .clk(iclk),
    .reset(ireset),
    .wr_en(read_fifo_wr_en),
    .rd_en(read_fifo_rd_en),
    .wr_data(read_fifo_wr_data),
    .rd_data(read_fifo_rd_data),
    .full(read_fifo_full),
    .empty(read_fifo_empty)
);


// FSM State Encoding
localparam S_INIT       = 4'd0,
           S_WAIT_INIT  = 4'd1,
           S_IDLE       = 4'd2,
           S_WRITE_REQ  = 4'd3,
           S_WRITE_WAIT = 4'd4,
           S_WRITE_ACK  = 4'd5,
           S_READ_REQ   = 4'd6,
           S_READ_WAIT  = 4'd7,
           S_READ_ACK   = 4'd8,
	   S_WRITE_POP  = 4'd9,
           S_READ_POP   = 4'd10,
	   S_READ_LATCH = 4'd11;

reg  [3:0] state, next_state;

// FSM control
reg init_ireq, write_ireq, read_ireq;
reg write_ack, read_ack;
reg [2:0] mul_state;  // 001=init, 010=write, 100=read

// Init, Read, Write done signals
wire init_fin;
wire write_fin;
wire read_fin;
reg        staged_write_valid;
reg [21:0] staged_write_addr;
reg [127:0] staged_write_data;


// Tristate / data control signals
wire [15:0] sdram_write_data;
wire        sdram_write_enable;
wire	    read_enable;

assign {read_ienb, write_ienb, init_ienb} = mul_state;
assign oinit_done = init_fin;
assign owrite_ack = write_ack;
assign oread_ack  = read_ack;

// Address Decode
wire [1:0] write_ibank, read_ibank;
wire [12:0] write_irow, read_irow;
wire [9:0] write_icolumn = 10'd0, read_icolumn = 10'd0;
assign {write_ibank, write_irow} = latched_write_address;

wire [127:0] write_data_reg;
assign write_data_reg = latched_write_data;

assign {read_ibank, read_irow} = latched_read_address;
	

// Tri-state
assign DRAM_DQ = sdram_write_enable ? sdram_write_data :
                 read_enable        ? 16'bz : 16'bz;

// FSM sequential logic
always @(posedge iclk)
    if (ireset)
        state <= S_INIT;
    else
        state <= next_state;

// Control logic: push into FIFOs if space is available
always @(posedge iclk) begin
    if (ireset) begin
        write_fifo_wr_en <= 0;
        read_fifo_wr_en  <= 0;
    end else begin
        // Default disables
        write_fifo_wr_en <= 0;
        read_fifo_wr_en  <= 0;

        if (staged_write_valid && !write_fifo_full) begin
            write_fifo_wr_en   <= 1;
            write_fifo_wr_data <= {staged_write_addr, staged_write_data};
	    $display("[%0t] --> FROM Controller FIFO WR ENABLED", $time);
        end

        if (iread_req && !read_fifo_full) begin
            read_fifo_wr_en   <= 1;
            read_fifo_wr_data <= iread_address;
        end
    end
end

// FSM combinational logic
always @(*) begin
    case (state)
        S_INIT:         next_state = S_WAIT_INIT;
        S_WAIT_INIT:    next_state = init_fin ? S_IDLE : S_WAIT_INIT;
        S_IDLE: begin
            if (!write_fifo_empty)      next_state = S_WRITE_POP;
            else if (!read_fifo_empty)  next_state = S_READ_POP;
            else                        next_state = S_IDLE;
        end
        S_WRITE_POP:    next_state = S_WRITE_REQ;
        S_WRITE_REQ:    next_state = S_WRITE_WAIT;
        S_WRITE_WAIT:   next_state = write_fin ? S_WRITE_ACK : S_WRITE_WAIT;
        S_WRITE_ACK:    next_state = (!write_fifo_empty) ? S_WRITE_POP :
                                     (!read_fifo_empty)  ? S_READ_POP  : S_IDLE;
	S_READ_POP: begin
    		if (!read_fifo_empty)
       		   next_state = S_READ_LATCH;
   		 else
                   next_state = S_IDLE;
	end
	S_READ_LATCH: next_state = S_READ_REQ;
        S_READ_REQ:     next_state = S_READ_WAIT;
        S_READ_WAIT:    next_state = read_fin ? S_READ_ACK : S_READ_WAIT;
        S_READ_ACK:     next_state = (!write_fifo_empty) ? S_WRITE_POP :
                                     (!read_fifo_empty && read_fin)  ? S_READ_POP  : S_IDLE;
        default:        next_state = S_INIT;
    endcase
end

// FSM output logic
always @(*) begin
    // Defaults
    init_ireq = 0; write_ireq = 0; read_ireq = 0;
    write_ack = 0; read_ack = 0;
    mul_state = 3'b000;
    
    

    write_fifo_rd_en   = 0;
    read_fifo_rd_en    = 0;

    case (state)
        S_INIT: begin
            init_ireq = 1;
            mul_state = 3'b001;
        end
        S_WAIT_INIT: begin
            mul_state = 3'b001;
        end
        S_IDLE: begin
            mul_state = 3'b001;
        end
        S_WRITE_POP: begin
            write_fifo_rd_en = 1;
        end
        S_WRITE_REQ: begin
            write_ireq = 1;
            mul_state  = 3'b010;
        end
        S_WRITE_WAIT, S_WRITE_ACK: begin
            mul_state = 3'b010;
            if (state == S_WRITE_ACK) write_ack = 1;
        end
        S_READ_POP: begin
           read_fifo_rd_en = 1;  // Pulse for one cycle
        end
        S_READ_LATCH: begin
           read_fifo_rd_en = 0;
        //   latched_read_address = read_fifo_rd_data;  // Safely latch after FIFO has output valid data
	end
        S_READ_REQ: begin
            read_ireq = 1;
            mul_state = 3'b100;
            $display("[%0t] >> Issuing Read to latched: ADDR=%h", $time, latched_read_address);
        end
        S_READ_WAIT, S_READ_ACK: begin
            mul_state = 3'b100;
            if (state == S_READ_ACK) read_ack = 1;
        end
    endcase

$display("[%0t] FSM State: %s", $time, 
    (state == S_INIT)       ? "S_INIT" :
    (state == S_WAIT_INIT)  ? "S_WAIT_INIT" :
    (state == S_IDLE)       ? "S_IDLE" :
    (state == S_WRITE_REQ)  ? "S_WRITE_REQ" :
    (state == S_WRITE_WAIT) ? "S_WRITE_WAIT" :
    (state == S_WRITE_ACK)  ? "S_WRITE_ACK" :
    (state == S_READ_REQ)   ? "S_READ_REQ" :
    (state == S_READ_WAIT)  ? "S_READ_WAIT" :
    (state == S_READ_ACK)   ? "S_READ_ACK"  : 
    (state == S_WRITE_POP)  ? "S_WRITE_POP" :
    (state == S_READ_POP)   ? "S_READ_POP" : "UNKNOWN"
 
);

end

always @(posedge iclk) begin
  if (ireset) begin
    latched_read_address <= 0;
  end else if (state == S_READ_LATCH) begin
    latched_read_address <= read_fifo_rd_data;
    $display("[%0t] >> Read FIFO latched in S_READ_LATCH: ADDR=%h", $time, read_fifo_rd_data);
  end
end

always @(posedge iclk) begin
    if (ireset) begin
        staged_write_valid <= 0;
    end else begin
        // 1. Push to FIFO if staged is valid and FIFO has space
        if (staged_write_valid && !write_fifo_full) begin
            write_fifo_wr_en   <= 1;
            write_fifo_wr_data <= {staged_write_addr, staged_write_data};
            staged_write_valid <= 0;  // Clear stage after pushing
        end else begin
            write_fifo_wr_en <= 0;  // No push
        end

        // 2. If TB issues new write and stage is empty, latch it
        if (iwrite_req && !staged_write_valid) begin
            staged_write_valid <= 1;
            staged_write_addr  <= iwrite_address;
            staged_write_data  <= iwrite_data;
        end
    end
end




always @(posedge iclk) begin
  if (ireset) begin
    latched_write_address <= 0;
    latched_write_data    <= 0;
  end else if (write_fifo_rd_en) begin
    latched_write_address <= write_fifo_rd_data[149:128];
    latched_write_data    <= write_fifo_rd_data[127:0];
    $display("[%0t] >> Write FIFO latched: ADDR=%h DATA=%h", $time, write_fifo_rd_data[149:128], write_fifo_rd_data[127:0]);
  end
  
end



always @(posedge iclk) begin
  if (state == S_IDLE && iwrite_req)
    $display("[%0t] TB pushed: ADDR = %h | DATA = %h", $time, iwrite_address, iwrite_data);

  if (write_fifo_wr_en)
    $display("[%0t] FIFO_WR: {ADDR+DATA} = %h", $time, write_fifo_wr_data);

  if (write_fifo_rd_en)
    $display("[%0t] FIFO_RD: ADDR = %h | DATA = %h", $time, write_fifo_rd_data[149:128], write_fifo_rd_data[127:0]);

  if (state == S_WRITE_REQ)
    $display("[%0t] --> S_WRITE_REQ: bank = %h, row = %h", $time, write_ibank, write_irow);



//read che debug statements
  if (state == S_IDLE && iread_req)
    $display("[%0t] TB pushed: ADDR = %h", $time, iread_address);

  if (read_fifo_wr_en)
    $display("[%0t] FIFO_WR_READ: ADDR = %h", $time, iread_address);

  if (read_fifo_rd_en)
    $display("[%0t] FIFO_RD_READ:", $time);

  if (state == S_READ_REQ)
    $display("[%0t] --> S_READ_REQ: bank = %h, row = %h", $time, read_ibank, read_irow);



  // Log every state transition and latching
  $display("[%0t] Current State: %d, Next State: %d", $time, state, next_state);

  // Log write FIFO status
  $display("[%0t] WRITE_FIFO | full=%b empty=%b wr_en=%b rd_en=%b", $time, write_fifo_full, write_fifo_empty, write_fifo_wr_en, write_fifo_rd_en);

// Log read FIFO status
$display("[%0t] READ_FIFO  | full=%b empty=%b wr_en=%b rd_en=%b", $time, read_fifo_full, read_fifo_empty, read_fifo_wr_en, read_fifo_rd_en);

// Log latched address and data
$display("[%0t] Latched Write Addr: %h | Data: %h", $time, latched_write_address, latched_write_data);
$display("[%0t] Latched Read Addr : %h", $time, latched_read_address);

// Log ack pulses
if (write_ack) $display("[%0t] --> WRITE_ACK pulse issued", $time);
if (read_ack)  $display("[%0t] --> READ_ACK pulse issued", $time);

if (staged_write_valid)
  $display("[%0t] Staged valid: ADDR=%h DATA=%h", $time, staged_write_addr, staged_write_data);


if (iwrite_req && staged_write_valid)
  $display("[%0t] WARNING: TB is sending write but stage is full. Potential loss!", $time);

end

// SDRAM Submodules
sdram_initalize sdram_init (
    .iclk(iclk), .ireset(ireset),
    .ireq(init_ireq), .ienb(init_ienb),
    .ofin(init_fin),
    .DRAM_ADDR(DRAM_ADDR), .DRAM_BA(DRAM_BA), .DRAM_CAS_N(DRAM_CAS_N),
    .DRAM_CKE(DRAM_CKE), .DRAM_CLK(DRAM_CLK), .DRAM_CS_N(DRAM_CS_N),
    .DRAM_DQ(DRAM_DQ), .DRAM_LDQM(DRAM_LDQM), .DRAM_RAS_N(DRAM_RAS_N),
    .DRAM_UDQM(DRAM_UDQM), .DRAM_WE_N(DRAM_WE_N)
);

sdram_write sdram_write (
    .iclk(iclk), .ireset(ireset),
    .ireq(write_ireq), .ienb(write_ienb),
    .irow(write_irow), .icolumn(write_icolumn), .ibank(write_ibank),
    .idata(write_data_reg), .ofin(write_fin),
    .write_data_out(sdram_write_data), .write_enable(sdram_write_enable),
    .DRAM_ADDR(DRAM_ADDR), .DRAM_BA(DRAM_BA), .DRAM_CAS_N(DRAM_CAS_N),
    .DRAM_CKE(DRAM_CKE), .DRAM_CLK(DRAM_CLK), .DRAM_CS_N(DRAM_CS_N),
    .DRAM_DQ(DRAM_DQ), .DRAM_LDQM(DRAM_LDQM), .DRAM_RAS_N(DRAM_RAS_N),
    .DRAM_UDQM(DRAM_UDQM), .DRAM_WE_N(DRAM_WE_N)
);

sdram_read sdram_read (
    .iclk(iclk), .ireset(ireset),
    .ireq(read_ireq), .ienb(read_ienb),
    .irow(read_irow), .icolumn(read_icolumn), .ibank(read_ibank),
    .odata(oread_data), .ofin(read_fin), .read_enable(read_enable),
    .DRAM_ADDR(DRAM_ADDR), .DRAM_BA(DRAM_BA), .DRAM_CAS_N(DRAM_CAS_N),
    .DRAM_CKE(DRAM_CKE), .DRAM_CLK(DRAM_CLK), .DRAM_CS_N(DRAM_CS_N),
    .DRAM_DQ(DRAM_DQ), .DRAM_LDQM(DRAM_LDQM), .DRAM_RAS_N(DRAM_RAS_N),
    .DRAM_UDQM(DRAM_UDQM), .DRAM_WE_N(DRAM_WE_N)
);

endmodule
